<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-wing-dnsop-dtls-over-dns-00"
     ipr="trust200902">
  <front>
    <title abbrev="DNS over DTLS">DNS over DTLS</title>

    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Cessna Business Park, Varthur Hobli</street>

          <street>Sarjapur Marathalli Outer Ring Road</street>

          <city>Bangalore</city>

          <region>Karnataka</region>

          <code>560103</code>

          <country>India</country>
        </postal>

        <email>tireddy@cisco.com</email>
      </address>
    </author>

    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>California</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>dwing@cisco.com</email>
      </address>
    </author>

    <author fullname="Prashanth Patil" initials="P." surname="Patil">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street/>

          <street/>

          <city>Bangalore</city>

          <country>India</country>
        </postal>

        <email>praspati@cisco.com</email>
      </address>
    </author>

    <date/>

    <workgroup>DNSOP Working Group</workgroup>

    <abstract>
      <t>DNS queries and responses are visible to network elements on
      the path between the DNS client and its server.  These queries
      and responses can contain privacy-sensitive information which is
      valuable to protect.  An active attacker can send bogus
      responses causing misdirection of the subsequent connection.</t>

      <t>To counter passive listening and active attacks, this
      document proposes the use of Datagram Transport Layer Security
      (DTLS) for DNS, to protect against passive listeners and certain
      active attacks.  As DNS needs to remain fast, this proposal also
      discusses mechanisms to reduce DTLS round trips and reduce DTLS 
      handshake size.  The proposed mechanism runs over the default
      DNS port and can also run over an alternate port.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="introduction" title="Introduction">
      <t>The Domain Name System is specified in
      <xref target="RFC1034"/> and <xref target="RFC1035"/>. DNS
      queries and responses are normally exchanged unencrypted and are
      thus vulnerable to eavesdropping.  Such
      eavesdropping can result in an undesired entity learning domains
      that a host wishes to access, thus resulting in privacy
      leakage. DNS privacy problem is further discussed in
      <xref target="I-D.bortzmeyer-dnsop-dns-privacy"/>.</t>

      <t>Active attackers have long been successful at injecting bogus
      responses, causing cache poisoning and causing misdirection of
      the subsequent connection (if attacking A or AAAA records).  A
      popular mitigation against that attack is to use ephemeral and
      random source ports for DNS queries.</t>

      <t>The mechanism described in this document provides 
      confidential DNS communication for stub resolvers, recursive resolvers,
      iterative resolvers and authoritative servers. The document only defines
      protocol extensions necessary to support DTLS negotiation.</t>
</section>

<section title="Relationship to DNSSEC">
      <t>DNS Security Extensions
      (<xref target="RFC4033">DNSSEC</xref>) provides response
      integrity by defining mechanisms to cryptographically sign
      zones, allowing end-users (or their first-hop resolver) to
      verify replies are correct. DNSSEC however does nothing to
      ensure DNS request or response privacy. Authenticity and
      integrity may be provided by DNSSEC, DNS over DTLS does not
      change DNSSEC and does not offer the means to authenticate
      responses. DNS over DTLS, however, does not preclude the use of
      DNSSEC. Since, in some cases, encryption is opportunistic with
      the use of DNS over DTLS, a DNS client may opt for DNSSEC for
      security reasons.</t>

</section>

<section title="Authenticating a DNS Server">
<t>As DTLS provides integrity protection, some protection from on-path
      attackers sending bogus responses is provided by simply using
      DTLS.  That is, a device on the path between a DNS client and
      its DNS server cannot simply inject a bogus DNS response, as
      could be done without DNS-over-DTLS.  However, that protection
      is not terribly strong, because that attacker could intercept the
      DTLS handshake itself and pretend to be the actual DNS server.</t>

      <t>To prevent an active attacker from pretending to be the
      legitimate DNS server, we need to resolve two problems:
      identifying the trusted servers and determinnig an appropriate
      action when no trusted servers are available.</t>

      <t>The first problem, of identifying the legitimate server,
      requires extending the host configuration.  This is because
      clients identify DNS servers by IP addresses (from DHCP or from
      /etc/resolv.conf file), but certificates have a DNS name in
      the SubjectAltName field.  It isn't useful to change how certificates
      are issued, but we have to modify the DNS client anyway to support
      DNS-over-DTLS.  With that in mind, the DNS client would have a
      list of SubjectAltNames it trusts, configured by the user.</t>

      <t>The second problem is an appropriate action when no trusted
     servers are available.  The DNS client could still use DNS-over-DTLS
     with an un-trusted server which still provides protection from 
     on-path passive listeners and from on- and off-path active attackers,
     but does not protect from a malicious server.  DNSSEC would protect
     from a malicious server.
	<list style="empty"><t>[[Editor's Note: Is there more we could
     do?  Trust certain responses (like for my enterprise VPN or other
     sites where I will be doing a TLS handshake)?  Keep in mind that
     with web portals at hotels/airports, we won't have access to a
     trusted DNS server on initial connect at all.]] </t></list></t>
</section>



    <section anchor="term" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"/>.</t>
    </section>

    <section anchor="problem_stmt" title="Usage">
      <t><list style="letters">
              <t>DNS forwarder uses DNS over DTLS to communicate with ISP DNS
              resolver and thus offers confidentiality in the last mile even
              if the stub resolver does not support DNS over DTLS.</t>

              <t>If a DNS resolver in an ISP does not support DNS over DTLS,
              the DNS forwarder or stub resolver can be configured to send DNS
              queries to DNS resolvers offered by public DNS servers.</t>
        </list></t>
    </section>

    <section title="Polling, Port Usage, and Discovery">
     <t>[Note - This section requires further discussion]</t>

     <t>Many modern operating systems already detect if a web proxy is
     interfering with Internet communications, using proprietary
     mechanisms that are out of scope of this document.  After that
     mechanism has run (and detected Internet connectivity is
     working), the DNS-over-DTLS procedure described in this document
     should commence.  This timing avoids delays in joining the
     network (and displaying an icon indicating successful Internet
     connection), at the risk that those initial DNS queries will be
     sent without protection afforded by DNS-over-DTLS.  </t>

     <t>DNS-over-DTLS can run over standard UDP port 53 as defined in
     <xref target="RFC1035"/>.  A DNS client or server that does not
     implement this specification will not respond to the incoming
     DTLS packets because they don't parse as DNS packets (the DNS
     Opcode would be 15, which is undefined).  A DNS client or server
     that does implement this specification can demultiplex DNS and
     DTLS packets by examining the third octet.  For TLS 1.2, which is
     what is defined by this specification, A DTLS packet will contain
     253 in the third octet, whereas a DNS packet will never contain
     253 in the third octet.</t>

<t><list style="empty"><t>If this demultiplexing is useful, we should
reserve the DNS Opcode 15.</t></list></t>

<t>There has been some concern with sending DTLS-over-DNS traffic
over the same port as normal, un-encrypted DNS traffic.  The intent
of this section is to show that DNS-over-DTLS could successfully
be sent over port 53.  Further analysis and testing on the Internet
may be valuable to determine if multiplexing on port 53, using
a separate port, or some fallback between a separate port and port
53 brings the most success.</t>



      <t>After performing the above steps, the host should determine
      if the DNS server supports DNS-over-DTLS by sending a DTLS
      ClientHello message.  A DNS server that does not support
      DNS-over-DTLS will not respond to ClientHello messages sent by
      the client, because they are not valid DNS requests
      (specifically, the DNS Opcode is invalid).  The client MUST use
      timer values defined in 4.2.4.1 of <xref target="RFC6347"/> for
      retransmission of ClientHello message and if no response is
      received from the DNS server.  After 15 seconds, it MUST cease
      attempts to re-transmit its ClientHello.  Thereafter, the client
      MAY repeat that procedure in the event the DNS server has been
      upgraded to support DNS over DTLS, but such probing SHOULD NOT
      be done more frequently than every 24 hours and MUST NOT be done
      more frequently than every 15 minutes.  This mechnism requires
      no additional signaling between the client and server. </t>
    </section>

    <section anchor="protocol" title="In-Band Signaling">
      <t>An alternate mechanism is to signal support for DTLS in band.</t>

<t>The authors have also briefly considered a DNS SRV query to ask if the DNS
server supports DTLS-over-DNS such as _dns_over_dtls._udp.well_known
assuming "well_known" is defined as
a <xref target="IANA-domain">special-use domain name</xref>.  That
query doesn't need to go beyond the DNS server itself.  An SRV query
is suggested so the port can be returned (assuming SRV is ubiquitously
available on clients?)</t>


      <section title="Use by  DNS clients">
        <section title="Sending Queries">
          <t>DNS clients MAY set the SO bit in queries sent using UDP
          transport to signal their general ability to support DNS over DTLS.
          [For discussion: is this a bad idea because ignorant middleboxes
          might drop the SO=1 UDP queries?]</t>

          <t>DNS clients MAY set the SO bit in the initial query sent to a
          server using UDP transport to signal their desire that the UDP
          connection be upgraded to DTLS. DNS clients MUST NOT set the SO bit
          on subsequent queries when already using DNS over DTLS.</t>

          <t>Since the motivation for DNS over DTLS is to preserve privacy,
          DNS clients SHOULD use a query that reveals no private information
          in the initial SO=1 query to a server. To provide a standard "dummy"
          query, it is RECOMMENDED to send the initial query with RD=0,
          QNAME="STARTDTLS", QCLASS=CH, and QTYPE=TXT ("STARTDTLS/CH/TXT")
          analogous to administrative queries already in widespread use <xref
          target="RFC4892"/>.</t>

          <t>After sending the initial SO=1 query using UDP transport, DNS
          clients MUST wait for the initial response before sending any
          subsequent queries over the same UDP connection.</t>
        </section>

        <section title="Receiving Responses">
          <t>A DNS client that receives a response using UDP transport that
          has the SO bit set MUST handle that response as usual. It MAY record
          the server's support for DNS over DTLS and use that information as
          part of its server selection algorithm in the case where multiple
          servers are available to service a particular query. [For
          discussion: UDP is subject to spoofing and a client which depends on
          SO=1 in a UDP response may be tricked into never upgrading to
          DTLS.]</t>

          <t>A DNS client that receives a response to its initial query using
          UDP transport that has the SO bit set MUST immediately initiate a
          DTLS handshake using the procedure described in <xref
          target="RFC6347"/>.</t>

          <t>A DNS client that receives a response to its initial query using
          UDP transport that has the SO bit clear MUST not initiate a DTLS
          handshake and SHOULD utilize the existing UDP connection for
          subsequent queries. DNS clients SHOULD remember server IP addresses
          that don't support DNS over DTLS and SHOULD NOT request DNS over
          DTLS from them for reasonable period. (We suggest 1 hour, or when
          the client discovers a new resolver)</t>
        </section>
      </section>

      <section title="Use by DNS Servers">
        <section title="Receving Queries">
          <t>A DNS server receiving a query over TCP MUST ignore the SO
          bit.</t>

          <t>A DNS server receiving a query over an existing DTLS session MUST
          ignore the SO bit.</t>

          <t>A DNS server receiving an initial query over UDP that has the SO
          bit set MAY inform the client it is willing to establish a DTLS
          session, as described in the next section.</t>

          <t>A DNS server receiving subsequent queries over a DTLS session
          MUST ignore the SO bit.</t>
        </section>

        <section title="Sending Responses">
          <t>A DNS server sending a response over UDP SHOULD set the SO bit to
          indicate its general support for DNS over DTLS, as long as it is
          willing and able to support a DTLS connection with the particular
          client. A DNS server receiving an initial query over UDP that has
          the SO bit set MAY set the TO bit in its response. The server MUST
          then proceed with the DTLS handshake protocol. A DNS server
          receiving a "dummy" STARTDTLS/CH/TXT query over UDP MUST respond
          with RCODE=0 and a TXT RR in the Answer section. Contents of the TXT
          RR are strictly informative (for humans) and MUST NOT be interpreted
          by the client software. Recommended TXT RDATA values are "STARTDTLS"
          or "NO_DTLS".</t>
        </section>
      </section>
    </section>

    <section anchor="DTLS" title="Established sessions">
      <t>In DTLS, all data is protected using the same record encoding and
      mechanisms. When the mechanism described in this document is in effect,
      DNS messages are encrypted using the standard DTLS record encoding. When
      a user of DTLS wishes to send an DNS message, it delivers it to the DTLS
      implementation as an ordinary application data write (e.g.,
      SSL_write()). A single DTLS session can be used to receive multiple DNS
      requests and generate DNS multiple responses.</t>

      <figure title="Message Flow for Full Handshake Issuing New Session Ticket">
        <artwork align="left"><![CDATA[
   Client                                          Server
   ------                                          ------

   ClientHello             -------->  
                         

                           <-------    HelloVerifyRequest  
                                         (contains cookie)    

   ClientHello             -------->     
   (contains cookie)                      
   (empty SessionTicket extension)
                                              ServerHello  
                                  (empty SessionTicket extension)  
                                             Certificate*    
                                       ServerKeyExchange*      
                                      CertificateRequest*     
                           <--------      ServerHelloDone    

   Certificate*                                             
   ClientKeyExchange                                          
   CertificateVerify*                                          
   [ChangeCipherSpec]                                         
   Finished                -------->                         
                                         NewSessionTicket
                                       [ChangeCipherSpec]    
                           <--------             Finished    

  
   DNS Request             --------->

                           <---------  DNS Response

]]></artwork>
      </figure>

      <t/>

      <t>After DTLS negotiation completes, the connection will be encrypted
      and is now protected from eavesdropping and normal DNS queries SHOULD
      take place. To avoid storing state on the DNS server and to reduce DTLS
      round-trips for another query, it is strongly RECOMMENDED both client
      and server support <xref target="RFC5077"/>.</t>

      <t><figure
          title="Message Flow for Abbreviated Handshake Using New Session Ticket">
          <artwork align="left"><![CDATA[
   Client                                          Server
   ------                                          ------

   ClientHello
   (SessionTicket extension) -------->
                                             ServerHello
                          (empty SessionTicket extension)
                                        NewSessionTicket
                                      [ChangeCipherSpec]
                             <--------          Finished
   [ChangeCipherSpec]
   Finished                  -------->

   DNS Request             --------->

                           <---------  DNS Response

]]></artwork>
        </figure></t>
    </section>


<section title="Performance Considerations">
<t>To reduce number of octets of the DTLS handshake, especially the
certificate sent by the server, we should examine viability of using
plain public keys <xref target="I-D.ietf-tls-oob-pubkey"/>.  As the
client already needs explicit configuration in a whitelist of the
DNS servers it trusts, maybe the public key configuration problem
is really no worse than the configuration problem of those whitelisted
certificates?</t>

<t>With normal DNS over UDP, the server maintains no state between
queries.  To keep the server state similarly low between queries,
the client can store the DTLS security association if both client
and server implement <xref target="RFC5077"/>.</t>

</section>

    <section title="IANA Considerations">
      <t>This document defines a new bit ("SO") in the Flags field of the
      EDNS0 OPT meta-RR. At the time of approval of this draft in the
      standards track, as per the IANA Considerations of <xref
      target="RFC6891"/>, IANA is requested to reserve the third leftmost bit
      of the flags as the SO bit, immediately adjacent to the DNSSEC SO bit,
      as shown in <xref target="protocol"/>.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>Security considerations discussed in <xref target="RFC6347"/> apply
      to this document.</t>
    </section>

    <section anchor="ack" title="Acknowledgements">
      <t>The Protocol changes described in <xref target="protocol"/> of this
      document was derived from the similar technique described in
      DNS-over-TLS <xref target="I-D.hzhwm-start-tls-for-dns"/>.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.1034"?>

      <?rfc include="reference.RFC.1035"?>

      <?rfc include="reference.RFC.4033"?>

      <?rfc include="reference.RFC.5077"?>

      <?rfc include="reference.RFC.6347"?>

      <?rfc include="reference.RFC.6891"?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.bortzmeyer-dnsop-dns-privacy'?>

      <?rfc include='reference.I-D.hzhwm-start-tls-for-dns'?>
      <?rfc include='reference.I-D.ietf-tls-oob-pubkey'?>

      <?rfc include="reference.RFC.4892"?>


      <reference anchor="IANA-domain" target="http://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml">
	<front>
          <title>Special-Use Domain Names</title>

          <author>
	    <organization>IANA</organization>
          </author>

          <date month="February" year="2013"/>
	  </front>
      </reference>



    </references>
  </back>
</rfc>

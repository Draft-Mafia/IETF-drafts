<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-reddy-mmusic-ice-happy-eyeballs-04"
     ipr="trust200902">
  <front>
    <title abbrev="Happy Eyeballs for ICE ">Happy Eyeballs Extension for
    ICE</title>

    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>Cessna Business Park, Varthur Hobli</street>
          <street>Sarjapur Marathalli Outer Ring Road</street>
          <city>Bangalore</city>
          <region>Karnataka</region>
          <code>560103</code>
          <country>India</country>
        </postal>
        <email>tireddy@cisco.com</email>
      </address>
    </author>

    <author fullname="Prashanth Patil" initials="P." surname="Patil">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street/>
          <city>Bangalore</city>
          <country>India</country>
        </postal>
        <email>praspati@cisco.com</email>
      </address>
    </author>

    <author fullname="Paal-Erik Martinsen" initials="P.E" surname="Martinsen">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>Philip Pedersens vei 22</street>
          <city>Lysaker</city>
          <region>Akershus</region>
          <code>1325</code>
          <country>Norway</country>
        </postal>
        <email>palmarti@cisco.com</email>
      </address>
    </author>

    <date/>

    <workgroup>MMUSIC</workgroup>

    <abstract>
      <t>This document provides guidelines on how to make ICE
      <xref target="RFC5245"/> conclude faster in IPv4/IPv6 dual-stack
      scenarios where broken paths exists.</t>
    </abstract>
  </front>

  <middle>
    
    <section anchor="introduction" title="Introduction">
      <t>
        There is a need to introduce more fairness in the handling of 
        connectivity checks in dual-stack IPv4/IPv6 ICE
        scenarios. Section 4.1.2.1 of ICE <xref target="RFC5245"/> points
        to <xref target="RFC3484"/> for prioritizing among the
        different IP families. <xref target="RFC3484"/> is obsoleted
        by <xref target="RFC6724"/> but following the recommendations
        from the updated RFC will still lead to prioritization of
        IPv6 over IPv4 with the same candidate type.
      </t>
      <t>
        As IPv6 is preferred over IPv4,
        recommendations made in this document help avoid user-noticeable delays
        when the IPv6 path is broken or excessively slow. This is
        achieved by making sure both address families are given a more
        "fair" treatment when prioritizing candidates, forming
        checklists or conducting connectivity checks.
      </t>
      
      <section anchor="notation" title="Notational Conventions">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in 
          <xref target="RFC2119"/>.</t>
        
        <t>This document uses terminology defined in <xref target="RFC5245"/>.</t>
      </section>
      
    </section>
    
    <section title="Improving ICE Dual-stack Fairness">
      <t>
        Candidates SHOULD be prioritized such
        that a long sequence of candidates belonging to the same address family
        be interleaved with candidates from the alternate IP family. For
        example, promoting IPv4 candidates in the presence of many IPv6
        addresses such that an IPv4 address candidate is always present after a
        small sequence of IPv6 addresses. This makes ICE
        connectivity checks more responsive to failures of an address family by
        reordering the candidates such that IPv6 and IPv4 candidates get a fair
        chance during connectivity checks.
      </t>
      
      <t>
        An ICE agent can choose an algorithm or a technique of its choice to
        promote IPv4 candidates. Appendix A describes several
        alternatives
      </t>
    </section>

    <section title="Compatibility">
      <t>Responsiveness of ICE candidate checks are much improved when both
      sides support Happy-Eyeballs.</t>

      <t><list style="symbols">
          <t>It is optimal when both agents support the same technique to
          promote IPv4 candidates in the candidate-list.</t>

          <t>If each  happens to use a different technique to promote IPv4
          candidates, ICE connectivity checks will be as responsive as the
          least aggressive algorithm. This is due to the fact that MAX/MIN
          logic used for calculating candidate-pair priority ensures that for
          a particular agent, a lower-priority candidate is never used until
          all higher-priority candidates have been tried</t>

          <t>If only one agent supports Happy-Eyeballs, there is
          potentially no change in pacing of ICE connectivity checks
          and the situation is no worse than
          what exists today.</t>
        </list></t>
    </section>

    <section title="IANA Considerations">
      <t>None.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>STUN connectivity check using MAC computed during key exchanged in
      the signaling channel provides message integrity and data origin
      authentication as described in section 2.5 of <xref target="RFC5245"/>
      apply to this use.</t>
    </section>

    <section anchor="ack" title="Acknowledgements">
      <t>Authors would like to thank Dan Wing, Ari Keranen, Bernard Aboba,
      Martin Thomson and Jonathan Lennox for their comments and review.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.3484"?>
      <?rfc include="reference.RFC.5245"?>
      <?rfc include="reference.RFC.6724"?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.RFC.2663'?>

      <?rfc include='reference.I-D.keranen-mmusic-ice-address-selection'?>

      <!---->
    </references>

    <section anchor="alg_overview" title="Examples">
      <section title="Candidate Promotion">
      <t>The following example illustrates how an ICE Agent can promote
      candidates as per the recommendation in this document. In this example,
      after candidates are prioritized using the formula in section 4.1.2.1 of
      <xref target="RFC5245"/>, highest-priority IPv4 candidates are placed
      after every sequence of 3 IPv6 candidates.</t>

      <t>The following figure illustrates the result of the algorithm on
      candidates:</t>

      <t><figure>
          <artwork><![CDATA[Before Happy Eyeballs Extension for ICE algorithm : 
----------------------------------------------------
 (highest)  IPv6 Host Candidate-1 
            IPv6 Host Candidate-2 
            IPv6 Host Candidate-3 
            IPv6 Host Candidate-4 
            IPv6 Host Candidate-5 
            IPv6 Host Candidate-6 
            IPv6 Host Candidate-7 
            IPv4 Host Candidate 
            IPv6 Server Reflexive Candidate  
            IPv4 Server Reflexive Candidate
            IPv6 Relayed Transport Candidate
 (lowest)   IPv4 Relayed Transport Candidate


After Happy Eyeballs Extension for ICE algorithm :
--------------------------------------------------
 (highest)  IPv6 Host Candidate-1 
            IPv6 Host Candidate-2 
            IPv6 Host Candidate-3 
            IPv4 Host Candidate               ---> Promoted candidate
            IPv6 Host Candidate-4 
            IPv6 Host Candidate-5
            IPv6 Host Candidate-6 
            IPv4 Server Reflexive Candidate   ---> Promoted candidate
            IPv6 Host Candidate-7 
            IPv6 Server Reflexive Candidate 
            IPv6 Relayed Transport Candidate 
 (lowest)   IPv4 Relayed Transport Candidate]]></artwork>
        </figure></t>
      </section>
      <section title="Local Preference">
        <t>
          This algorithm  does not take into account SRFLX and RELAY
          candidates. All the host candidates would be tried before
          any of those. 
        </t>
        <t>
          1. Create a local preference table (Pref_M) with M rows. 
          M roughly equals the number of interfaces * number ip 
          address types. The initial value at index 0 ( M=0, Pref_0) 
          should be set to 65534, 65535 is reserved for single homed 
          agents. Subsequent M (Pref_M) values is set by taking the 
          value of M-1 and subtracting the number allowed candidates 
          (Pref_1 = Pref_0 - number_of_allowed_candidates).
        </t>
        <t>
        2. Decide which M value belongs to what Interface/IP_addr_Type pair.
        </t>
        <t>
          3. When computing the candidate priority use the formula
          described 
          in ICE, but use the local_preference from the preference table. 
        </t>
        <t>
          4. If any preference value M have been used N times, then M
          is set to the value in M+(Actually_used/N) decreased by
          one. If M+1 does not exist the value should be set to 
          M = M - number_of_allowed_candidates -1
        </t>
        
        <texttable anchor="table_ex" title="Local Pref list">
          <ttcol align='center'>Interface #</ttcol>
          <ttcol align='center'>IP_Type</ttcol>
          <ttcol align='center'>Pref_M</ttcol>
          <ttcol align='center'>Initial Value</ttcol>
          <c>eth0</c>
          <c>4</c>
          <c>Pref_1</c>
          <c>65434</c>
          <c>eth0</c>
          <c>6</c>
          <c>Pref_0</c>
          <c>65534</c>
          <c>eth1</c>
          <c>6</c>
          <c>Pref_2</c>
          <c>65334</c>
          <c>eth1</c>
          <c>4</c>
          <c>Pref_3</c>
          <c>65234</c>
          
        </texttable>
        <t>
          Unsorted List (Only with eth0) (The algorithm is not
          agnostic to the order you add the candidates, but it 
          will still ensure an even spread)
        </t>
        <figure><artwork><![CDATA[
          6   Pref_0     65534 (1) 
          6   Pref_0     65534 (1)
          6   Pref_0     65534 (1) 
          6   Pref_0     65433 (3) (Pref value changed)
          6   Pref_0     65433 (3)
          4   Pref_1     65434 (2)
          4   Pref_1     65434 (2)
          6   Pref_0     65433 (3)
          6   Pref_0     65233 (5) (Pref value changed)
          4   Pref_1     65434 (2)
          4   Pref_1     65333 (4) (Pref Value Changed)
          6   Pref_0     65233 (5)
          
          Sorted: 6,6,6,4,4,4,6,6,6,4,6,6
      
]]></artwork></figure>
        
      </section>
    </section>
  </back>
</rfc>
